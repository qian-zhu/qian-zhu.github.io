<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Techology &amp; Finance</title><link href="/" rel="alternate"></link><link href="/feeds/all.atom.xml" rel="self"></link><id>/</id><updated>2014-09-10T00:00:00+02:00</updated><entry><title>Permission in Django</title><link href="/permission_in_django.html" rel="alternate"></link><updated>2014-09-10T00:00:00+02:00</updated><author><name>Qian Zhu</name></author><id>tag:,2014-09-10:permission_in_django.html</id><summary type="html">&lt;p&gt;Django的permission系统即可以针对一个Model,也可以针对一个Model的Instance.&lt;/p&gt;
&lt;p&gt;django.contrib.auth.models中有User这个Model.其中有一个ManyToMany relationship to django.contrib.auth.models.Permission的field: user_permissions&lt;/p&gt;
&lt;p&gt;class models.User中有&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;has_perm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;perm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Returns True if the user has the specified permission, where perm is in the format "&lt;app label&gt;.&lt;permission codename&gt;". If the user is inactive, this method will always return False.&lt;/p&gt;
&lt;p&gt;If &lt;strong&gt;obj&lt;/strong&gt; is passed in, this method won’t check for a &lt;strong&gt;permission&lt;/strong&gt; for the model, but for this &lt;strong&gt;specific object&lt;/strong&gt;.&lt;/p&gt;</summary><category term="Python"></category><category term="Django"></category></entry><entry><title>Git小技巧.md</title><link href="/gitxiao-ji-qiao-md.html" rel="alternate"></link><updated>2014-08-21T00:00:00+02:00</updated><author><name>Qian Zhu</name></author><id>tag:,2014-08-21:gitxiao-ji-qiao-md.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;git push origin :temp  -- 删除remote的temp branch。意思是用空的branch替换temp branch&lt;/li&gt;
&lt;/ol&gt;</summary><category term="git"></category><category term="tools"></category></entry><entry><title>decorator application context</title><link href="/decorator%20application%20context.html" rel="alternate"></link><updated>2014-08-12T00:00:00+02:00</updated><author><name>Qian Zhu</name></author><id>tag:,2014-08-12:decorator application context.html</id><summary type="html">&lt;h3&gt;@precondition&lt;/h3&gt;
&lt;h3&gt;@postcondition&lt;/h3&gt;
&lt;h3&gt;@assert_range&lt;/h3&gt;
&lt;h3&gt;@assert_type&lt;/h3&gt;
&lt;h3&gt;@stress_data&lt;/h3&gt;</summary><category term="python"></category><category term="decorator"></category></entry><entry><title>Decorators in Python</title><link href="/decorators%20in%20python.html" rel="alternate"></link><updated>2014-08-07T00:00:00+02:00</updated><author><name>Qian Zhu</name></author><id>tag:,2014-08-07:decorators in python.html</id><summary type="html">&lt;h2&gt;Closure&lt;/h2&gt;
&lt;p&gt;Python 中有decorator这个概念首先要归功于python支持&lt;strong&gt;function closure&lt;/strong&gt; : inner functions defined in non-global scope remember what their enclosing namespaces looked like at definition time. &lt;/p&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;outer&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;inner&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;inner&lt;/span&gt;

&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;outer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据python的variable lifetime, x是outer的local variable.那么当outer返回后x应该不存在了。但在这里我们通过 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cell_contents&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__closure__&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到x还是存在的。被记录到了inner function的__closure__这个属性里面.&lt;/p&gt;
&lt;h2&gt;Function is an object&lt;/h2&gt;
&lt;p&gt;其次就是在python中，everything is object. 函数也是object, 而且是first class object. 比如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__class__&lt;/span&gt; &lt;span class="c"&gt;# &amp;lt;type &amp;#39;function&amp;#39;&amp;gt;&lt;/span&gt;
&lt;span class="nb"&gt;issubclass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__class__&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这就表示function也可以作为普通的object传给另一个function作为参数.
比如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;outer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;inner&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;before function&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;inner&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="n"&gt;decorated&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;outer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;decorated&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;#before function&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="c"&gt;#2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而且foo.__name__就是代表函数的名字。通过&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;functools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;wraps&lt;/span&gt; 
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;outer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nd"&gt;@wraps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;inner&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;before function&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;inner&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样使得decorator返回的被装饰后的函数的名字function.__name__和原函数相同。&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;args and &lt;/em&gt;*kwargs&lt;/h2&gt;
&lt;p&gt;如果没有这两个可以代表任意函数参数的变量，那么每一个function都是要事先确定好参数的个数，decorator的作用范围变窄了。
比如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;logger&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;inner&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c"&gt;# some code&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;inner&lt;/span&gt;
&lt;span class="nd"&gt;@logger&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;比如这里被logger decorate的函数参数可以是任意的。&lt;/p&gt;</summary><category term="python"></category><category term="decorators"></category><category term="closure"></category></entry><entry><title>Items order in dictionary</title><link href="/dictionary%20in%20python.html" rel="alternate"></link><updated>2014-08-05T00:00:00+02:00</updated><author><name>Qian Zhu</name></author><id>tag:,2014-08-05:dictionary in python.html</id><summary type="html">&lt;p&gt;dictionary在Python中是由hash table实现的。既然涉及到了hash table,就涉及到了两个问题:
1. hash value是如何计算的？
2. 如何处理hash的collision的?&lt;/p&gt;
&lt;p&gt;在CPython中,python2.7的hash(x) == id(x)/16, 然后选取最后面的n位作为其index. 比如说，在dict初始化时，就有8个slots，那么元素x的index就是hash(x)%8,当有2/3的slots被占用时，再double下dict的size&lt;/p&gt;
&lt;p&gt;采用的&lt;a href="http://en.wikipedia.org/wiki/Hash_table#Open_addressing"&gt;open addressing&lt;/a&gt;, hash table其实是一个连续的地址（类似数组），如果object的primary position被占用了，那么将根据&lt;a href="http://hg.python.org/cpython/file/52f68c95e025/Objects/dictobject.c#l33"&gt;random probing&lt;/a&gt;算法去找到下一个地址。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;B&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;C&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;D&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;E&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;F&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;G&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;G&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iteritems&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__name__&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;bin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过这个示例程序，我们发现为什么id(x)/16的后8位在每次运行都是相同的?在Python中，id就是object的内存地址。为什么id(x)/16会一直相同的？难道是因为Python中，dict这一块内存都是32字节对其的的？&lt;/p&gt;</summary><category term="python"></category><category term="dictionary"></category></entry><entry><title>Blocking vs Non-blocking, Syn vs Asyc</title><link href="/Blocking%20vs%20Non-blocking,%20Syn%20vs%20Asyc.html" rel="alternate"></link><updated>2014-07-26T00:00:00+02:00</updated><author><name>Qian Zhu</name></author><id>tag:,2014-07-26:Blocking vs Non-blocking, Syn vs Asyc.html</id><summary type="html">&lt;h1&gt;Simplified matrix of basic Linux I/O models&lt;/h1&gt;
&lt;p&gt;&lt;img alt="Simplified matrix of basic Linux I/O models" src="images/System/io_type.gif" /&gt;&lt;/p&gt;
&lt;h1&gt;Blocking vs Non-blocking&lt;/h1&gt;
&lt;p&gt;这两者的区分仅仅在于是否会阻塞当前进程上。如果会阻塞就是blocking,如果不会阻塞，无论是采用什么方法，都属于non-blocking.&lt;/p&gt;
&lt;p&gt;比如在Linux中，通过fcntl可以设置O_NONBLOCK。当文件当前不可读/可写时，自动返回一个错误值。这属于sync and non-blocking.&lt;/p&gt;
&lt;h1&gt;Asynchronous vs Synchronous&lt;/h1&gt;
&lt;p&gt;区别主要是同步的方式。Synchronous通过时钟同步，Asynchronous通过信号同步。Asynchronous and blocking I/O也是存在的。比如Linux中select的系统调用。&lt;/p&gt;
&lt;p&gt;select监视若干个文件并且在background运行一个timer，如果文件中有一个可以读/写，或者timer到期，都返回。会阻塞当前进程，但是确实Async&lt;/p&gt;</summary><category term="System"></category></entry><entry><title>Inheritance in js</title><link href="/Inheritance%20in%20javascript.html" rel="alternate"></link><updated>2014-07-26T00:00:00+02:00</updated><author><name>Qian Zhu</name></author><id>tag:,2014-07-26:Inheritance in javascript.html</id><summary type="html">&lt;p&gt;JavaScript is a &lt;strong&gt;class-free&lt;/strong&gt;, &lt;strong&gt;object-oriented&lt;/strong&gt; language, and as such, it uses &lt;strong&gt;prototypal inheritance&lt;/strong&gt; instead of classical inheritance. &lt;a href="http://www.crockford.com/javascript/inheritance.html"&gt;1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有几点关键的:&lt;/p&gt;
&lt;p&gt;Javascript没有class的概念，在class based的语言中(Python,java,C++)，开始先定义一个class，然后再跟进这个class实例化一个object。在JS中，object是从另一个object创建（不是实例化）的。&lt;/p&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Vehicle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;hasEngine,hasWheels&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hasEngine&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hasEngine&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hasWheels&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hasWheels&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Vehicle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里Vehicle是一个function object. v是一个通过这个function object创建的object.&lt;/p&gt;
&lt;p&gt;Prototype构成了一个chain. 用于实现继承。比如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Car&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;make,model,hp&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hp&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;make&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;Car&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;prototype&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Vehicle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;Car&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;prototype&lt;/span&gt; 指向&lt;span class="n"&gt;Vehicle&lt;/span&gt;
&lt;span class="n"&gt;Car&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;prototype&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;constructor&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Car&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;使得&lt;span class="n"&gt;instance&lt;/span&gt; &lt;span class="n"&gt;object&lt;/span&gt;的&lt;span class="n"&gt;constructor&lt;/span&gt;指向&lt;span class="n"&gt;Car&lt;/span&gt;
&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;car&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Car&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;audi&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a6&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;120&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nb"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;car&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hasWheels&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt;这里输出&lt;span class="n"&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到这里prototype based实现继承的一个好处，能够给被继承的object传参数。当然在class based的方式中也可以通过构造函数，改变父类中的值。但是没这么清楚，隔离。&lt;/p&gt;
&lt;p&gt;一个object的prototype是所有被这个object创建的instance object的公共部分。&lt;/p&gt;</summary><category term="javascript"></category></entry><entry><title>Event Loop</title><link href="/event%20loop.html" rel="alternate"></link><updated>2014-07-26T00:00:00+02:00</updated><author><name>Qian Zhu</name></author><id>tag:,2014-07-26:event loop.html</id><summary type="html">&lt;h1&gt;Event loop and message queue&lt;/h1&gt;
&lt;p&gt;Event-loop和Message Queue是js中实现callback的方法。比如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;link&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;document&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getElementById&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="nx"&gt;link&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;addEventListener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;click&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;changeColor&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;style&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;black&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="p"&gt;});&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nx"&gt;init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里执行init,然后init添加了一个callback函数。具体的执行流程如下图所示:
&lt;img alt="javascript event loop" src="images/Javascript/javascript_event_loop.png" /&gt;&lt;/p&gt;
&lt;p&gt;Event loop首先执行init,然后init调用addEventListener,通知browser注册一个function handler。当用户点击link时，browser把一个message(包含事件，以及callback函数)放入js的Message Queue中。&lt;/p&gt;
&lt;p&gt;当Event Loop执行完在stack中的function后，会去message queue取地一个message，然后继续这个循环。这里显然是有异步操作的，但是这和js是单线程的并不矛盾。因为当用户点击link，然后生成一个message并且放入message queue是browser完成的。和js的执行环境没有关系。js不过是browser和用户交互的一个脚本语言。browser中还有很多其他的部分。&lt;/p&gt;
&lt;p&gt;优点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在js中不需要并发的操作。使js简单。&lt;/li&gt;
&lt;li&gt;在I/O bound的环境下表现的很好。但是在CPU-bound下表现不好。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;HTML5: Unblock w/Web Workers&lt;/h1&gt;
&lt;p&gt;在HTML5中，添加了一个新的特性:&lt;strong&gt;workers&lt;/strong&gt;. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Additional thread of execution for offloading expensive operations&lt;/li&gt;
&lt;li&gt;Separate event loop, message queue,stack&lt;/li&gt;
&lt;li&gt;Communicate with main thread through messaging&lt;/li&gt;
&lt;li&gt;Supported by all modern browsers + IE10&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="workers in javascript" src="images/Javascript/works_in_html5.png" /&gt;&lt;/p&gt;
&lt;p&gt;可以看到js中能够建立一个有独立event loop,message queue,和stack的worker去执行一些function. 当执行完毕后通过message和main thread通信。&lt;/p&gt;</summary><category term="System"></category></entry><entry><title>javascript level</title><link href="/javascript%20level.html" rel="alternate"></link><updated>2014-07-22T00:00:00+02:00</updated><author><name>Qian Zhu</name></author><id>tag:,2014-07-22:javascript level.html</id><summary type="html">&lt;p&gt;&lt;img alt="Javascript" src="/images/javascript_level.png" /&gt;&lt;/p&gt;
&lt;p&gt;Javascript负责交互，但是其作为一个语言，在语法层面很弱了。很多面向对象的抽象都没有，extend,mixin,package这些概念都没有，必须通过其他方式实现。而且其在不同的浏览器上行为也不一致。所以有了很多的框架:jQuery, dojo等弥补这些功能上的不足。&lt;/p&gt;
&lt;h2&gt;封装(package),解决命名冲突:&lt;/h2&gt;
&lt;h3&gt;css上:&lt;/h3&gt;
&lt;p&gt;tabview.css&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nc"&gt;.menu&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;xxx&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nc"&gt;.content&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;xxx&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;treeview.css&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nc"&gt;.menu&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;xxx&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nc"&gt;.content&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;xxx&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到这两个css如果加载到同一个html文件下会产生冲突。解决方法有两个:&lt;/p&gt;
&lt;p&gt;1.利用html的层级关系。&lt;/p&gt;
&lt;p&gt;比如将tabview.css写做:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nc"&gt;.tabview&lt;/span&gt; &lt;span class="nc"&gt;.menu&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;xxx&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nc"&gt;.tabview&lt;/span&gt; &lt;span class="nc"&gt;.content&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;xxx&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.在css每个元素都加上前缀:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nc"&gt;.tabview_menu&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;xxx&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nc"&gt;.tabview_content&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;xxx&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;很多人用第一种方法，但是这里有个问题——依赖了html的层级关系。但是我们知道html负责结构，css是负责效果呈现。css应该和html尽可能的独立。所以这里依赖html已有的结构是部正确的。方法2比较合适，而且简单。&lt;/p&gt;
&lt;h3&gt;Javascript上:&lt;/h3&gt;
&lt;p&gt;利用闭包(closure)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;abc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;})()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里的abc就不是全局的了。&lt;/p&gt;
&lt;h2&gt;依赖关系:&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.requirejs.org/"&gt;requirejs&lt;/a&gt; : 将js的文件，抽象出package。可以解决package之间的依赖关系。&lt;/p&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//main.js 入口函数&lt;/span&gt;
&lt;span class="nx"&gt;require&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;tabview&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;treeview&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;tab&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;tree&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;tabView&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;tab&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TabView&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
        &lt;span class="nx"&gt;treeView&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;tree&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TreeView&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//tabview.js&lt;/span&gt;
&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;animate&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;TabView&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;animate&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Animate&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;TabView&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;TabView&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//treeview.js&lt;/span&gt;
&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;TreeView&lt;/span&gt;&lt;span class="p"&gt;(){}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;TreeView&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;TreeView&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//animate.js&lt;/span&gt;
&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;Animate&lt;/span&gt;&lt;span class="p"&gt;(){};&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;Animate&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;Animate&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;requirejs会自动的load js文件，并且解决依赖关系&lt;/p&gt;
&lt;p&gt;源代码里面只需要添加:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="nt"&gt;&amp;lt;script &lt;/span&gt;&lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;js/require.js&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;data-main=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;js/main&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就可以了。不需要手动的加载很多的js文件&lt;/p&gt;</summary><category term="javascript"></category></entry><entry><title>Object in js</title><link href="/object%20in%20javascript.html" rel="alternate"></link><updated>2014-07-19T00:00:00+02:00</updated><author><name>Qian Zhu</name></author><id>tag:,2014-07-19:object in javascript.html</id><summary type="html">&lt;h1&gt;General&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://www.smashingmagazine.com/2013/04/18/introduction-to-programming-type-systems/"&gt;An Introdunction to Programming Type systems&lt;/a&gt; 解释了比较了dynamic/static 以及 strong/weak 类型的编程语言。其中javascript属于strong and dynamic类型。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Python, JavaScript and Ruby&lt;/strong&gt; dynamically infer the types of objects, instead of forcing you to define them, and then enforce those types when the program runs in the interpreter. 
All dynamically typed languages need a strong typing system at runtime or else they won’t be able to resolve the object types.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在javacript中，几乎所有的东西的都是object. JS内置了9个object的constructer &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Object()&lt;/li&gt;
&lt;li&gt;Function()&lt;/li&gt;
&lt;li&gt;Number()&lt;/li&gt;
&lt;li&gt;String()&lt;/li&gt;
&lt;li&gt;Boolean()&lt;/li&gt;
&lt;li&gt;Array()&lt;/li&gt;
&lt;li&gt;Date()&lt;/li&gt;
&lt;li&gt;RegExp()&lt;/li&gt;
&lt;li&gt;Error()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;javascript 是一种 &lt;a href="http://en.wikipedia.org/wiki/Prototype-based_programming"&gt;prototype based programming&lt;/a&gt; 的语言,和python之类class based programming还是不同的。class based programming中，class是一个抽象的概念。而prototype based中，没有抽象的class，Object/Function都是一个object.具体可以参考:&lt;a href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=2451F21EBF8EF1C8C094C28E1AE735A2?doi=10.1.1.56.4713&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Classes vs. Prototypes Some Philosophical and Historical Observations&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Javascript可以说就是由这9个object构建的. 还有string,number,true,false,null,undefined等是primitive values. 对其的引用和复制是基于value的。而对于object是基于&lt;strong&gt;引用&lt;/strong&gt;的——通过object的名字找到object对应的引用。这9个Object是有层级关系的，Object是他们的父对象。不同的对象有不同的属性。构成了整个JS的基石。&lt;/p&gt;
&lt;p&gt;Javascript是一个dynamic的语言，也体现在complex object是有动态的属性的。可以在运行时改变/添加/删除object的属性。这里注意是改变object的属性，而不是他的constructor.&lt;/p&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;Person&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;living&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;age&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;gender&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;living&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;living&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;age&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;age&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;gender&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;gender&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getGender&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;gender&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;cody&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;male&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nx"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;greeding&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;lisa&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;female&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nx"&gt;lisa&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;greeding&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里lisa.greeding()会提示找不到这个method的错误。但是如果我们这样修改:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;44&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;male&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;greeding&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nb"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;greeding&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里hi.greeding()会打印hello. &lt;/p&gt;
&lt;h1&gt;References to objects properties are resolved&lt;/h1&gt;
&lt;p&gt;Javascript有一个奇怪的特性。可以通过方括号的形式来引用Object的成员。我想原因可能有几点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Array也是一个Object，这样通过方括号的形式在Array()就自然了。&lt;/li&gt;
&lt;li&gt;可以将变量，作为Object中成员的索引。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;string1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;string2&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;bar&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nb"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foobarObject&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;string1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;string2&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;访问Object中的一个成员，先访问自有的成员(hasOwnProperty),然后顺着prototype的chain，不断向父Object的prototype找。通过这种方法，实现&lt;strong&gt;继承&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;gender&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;gender&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;gender&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;Worker&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;number&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nx"&gt;Worker&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;prototype&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里Worker继承了Person&lt;/p&gt;</summary><category term="javascript"></category><category term="Vim"></category></entry><entry><title>Pratical Vim</title><link href="/pratical_vim.html" rel="alternate"></link><updated>2014-07-19T00:00:00+02:00</updated><author><name>Qian Zhu</name></author><id>tag:,2014-07-19:pratical_vim.html</id><summary type="html">&lt;h1&gt;What is the idea behind vim?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Vim is optimized for repetition.Act,repeat, reverse &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;vim不是一大堆插件以及一大堆的命令。很多人觉得vim难以上手也是因为不了解vim的精髓。Dot command 是vim中处理重复操作基本命令.需要注意的是"."重复上一组&lt;strong&gt;修改&lt;/strong&gt;而不是&lt;strong&gt;跳转&lt;/strong&gt;的动作&lt;/p&gt;
&lt;p&gt;举个例子:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Keystrokes&lt;/th&gt;
&lt;th&gt;Buffer Contents&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;{start}&lt;/td&gt;
&lt;td&gt;...We're waiting for content before the site can go live If you are &lt;strong&gt;c&lt;/strong&gt;ontent with this, let's go ahead with it We'll launch as soon as we have the content&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;...We're waiting for &lt;strong&gt;content&lt;/strong&gt; before the site can go live.If you are &lt;strong&gt;content&lt;/strong&gt; with this, let's go ahead with it.We'll launch as soon as we have the &lt;strong&gt;content&lt;/strong&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cwcopy&lt;Esc&gt;&lt;/td&gt;
&lt;td&gt;...We're waiting for content before the site can go live.If you are content with this, let's go ahead with it.We'll launch as soon as we have the &lt;strong&gt;copy&lt;/strong&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;...We're waiting for &lt;strong&gt;content&lt;/strong&gt; before the site can go live.If you are &lt;strong&gt;content&lt;/strong&gt; with this, let's go ahead with it.We'll launch as soon as we have the copy...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;...We're waiting for &lt;strong&gt;copy&lt;/strong&gt; before the site can go live.If you are content with this, let's go ahead with it.We'll launch as soon as we have the copy...&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1&gt;Compose Repeatable Changes&lt;/h1&gt;
&lt;p&gt;Suppose our cursor is positioned on the "h", and we want to delete the word "nigh"&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The end is nigh&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Method 1:&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Keystrokes&lt;/th&gt;
&lt;th&gt;Buffer Contents&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;{start}&lt;/td&gt;
&lt;td&gt;The end is nig&lt;strong&gt;h&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;db&lt;/td&gt;
&lt;td&gt;The end is h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;The end is&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;"." repeat "x"&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;Method 2:&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Keystrokes&lt;/th&gt;
&lt;th&gt;Buffer Contents&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;{start}&lt;/td&gt;
&lt;td&gt;The end is nig&lt;strong&gt;h&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;The end is nigh&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dw&lt;/td&gt;
&lt;td&gt;The end is&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;"." repeat "dw"&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;Method 3:&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Keystrokes&lt;/th&gt;
&lt;th&gt;Buffer Contents&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;{start}&lt;/td&gt;
&lt;td&gt;The end is nig&lt;strong&gt;h&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;daw&lt;/td&gt;
&lt;td&gt;The end is&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;"." repeat "daw"&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Method 3 is the best one. &lt;/p&gt;
&lt;h1&gt;Register + Operator + Motion = Action&lt;/h1&gt;
&lt;p&gt;d{motion} :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dl : delete a single character&lt;/li&gt;
&lt;li&gt;daw: delete a complete word&lt;/li&gt;
&lt;li&gt;dap : delete a paragraphy&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;d,c,y 都属于operator, l,aw,ap属于motion，说明operator作用的对象。vim基本的语法就是operator + motion.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;"ayy: yank current line to register a&lt;/li&gt;
&lt;li&gt;"ayiw: yank current inner work to register a&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Operator:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;a : around 删除word,包括周边空格&lt;/li&gt;
&lt;li&gt;i : inner 删除字,但是不包括周围空格&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Register&lt;/h2&gt;
&lt;h3&gt;The Unnamed Register ("")&lt;/h3&gt;
&lt;p&gt;默认寄存器就是"", 所以&lt;strong&gt;dd&lt;/strong&gt;相当于&lt;strong&gt;""dd&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;The Yank Register : "0&lt;/h3&gt;
&lt;p&gt;yank register. 顾名思义就是在yank使会更新的register. 这个的好处就是不会被dd,diw这些命令覆盖了之前yank的内容。&lt;/p&gt;
&lt;h3&gt;The black hole register("_)&lt;/h3&gt;
&lt;p&gt;A place from which nothing returns. &lt;/p&gt;
&lt;h3&gt;More Registers:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;"% : Name of the current file&lt;/li&gt;
&lt;li&gt;"# : Name of the alternate file&lt;/li&gt;
&lt;li&gt;". : Last inserted text&lt;/li&gt;
&lt;li&gt;": : Last Ex command&lt;/li&gt;
&lt;li&gt;"/ : Last search pattern -- it can be set explicitly using &lt;em&gt;:let&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Commands&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;reg : show all register content&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Tools"></category><category term="Vim"></category></entry><entry><title>How to publish a Pelican site in the form of User Pages?</title><link href="/publish-pelican.html" rel="alternate"></link><updated>2014-07-19T00:00:00+02:00</updated><author><name>Qian Zhu</name></author><id>tag:,2014-07-19:publish-pelican.html</id><summary type="html">&lt;p&gt;You need to push the cotent of &lt;strong&gt;output&lt;/strong&gt; dir generated by Pelican to the &lt;strong&gt;master branch&lt;/strong&gt; of your &lt;username&gt;.github.io repository on GitHub&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pelican&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;pelicanconf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
&lt;span class="n"&gt;ghp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;import&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;github&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;qian&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;zhu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;qian&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;zhu&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;github&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;gh&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pages&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;master&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;force&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里通过ghp-import output将output里面的内容merge到gh-pages这个branch，然后将gh-pages这个branch push到remote的master branch&lt;/p&gt;
&lt;p&gt;若已本地的文章为准，使用--force强制更新remote的branch&lt;/p&gt;
&lt;p&gt;这里，使用的是&lt;a href="https://github.com/DandyDev/pelican-bootstrap3"&gt;pelican-bootstrape3&lt;/a&gt;的theme, 可以在env/lib/python2.7/site-packages/pelica/theme对theme进行自定义&lt;/p&gt;
&lt;p&gt;deploy的步骤还可以参考&lt;a href="http://docs.getpelican.com/en/3.3.0/tips.html"&gt;官方文档&lt;/a&gt;&lt;/p&gt;</summary><category term="Tools"></category><category term="Pelican"></category></entry></feed>