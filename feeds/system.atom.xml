<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Techology &amp; Finance</title><link href="/" rel="alternate"></link><link href="/feeds/system.atom.xml" rel="self"></link><id>/</id><updated>2014-07-26T00:00:00+02:00</updated><entry><title>Blocking vs Non-blocking, Syn vs Asyc</title><link href="/Blocking%20vs%20Non-blocking,%20Syn%20vs%20Asyc.html" rel="alternate"></link><updated>2014-07-26T00:00:00+02:00</updated><author><name>Qian Zhu</name></author><id>tag:,2014-07-26:Blocking vs Non-blocking, Syn vs Asyc.html</id><summary type="html">&lt;h1&gt;Simplified matrix of basic Linux I/O models&lt;/h1&gt;
&lt;p&gt;&lt;img alt="Simplified matrix of basic Linux I/O models" src="images/System/io_type.gif" /&gt;&lt;/p&gt;
&lt;h1&gt;Blocking vs Non-blocking&lt;/h1&gt;
&lt;p&gt;这两者的区分仅仅在于是否会阻塞当前进程上。如果会阻塞就是blocking,如果不会阻塞，无论是采用什么方法，都属于non-blocking.&lt;/p&gt;
&lt;p&gt;比如在Linux中，通过fcntl可以设置O_NONBLOCK。当文件当前不可读/可写时，自动返回一个错误值。这属于sync and non-blocking.&lt;/p&gt;
&lt;h1&gt;Asynchronous vs Synchronous&lt;/h1&gt;
&lt;p&gt;区别主要是同步的方式。Synchronous通过时钟同步，Asynchronous通过信号同步。Asynchronous and blocking I/O也是存在的。比如Linux中select的系统调用。&lt;/p&gt;
&lt;p&gt;select监视若干个文件并且在background运行一个timer，如果文件中有一个可以读/写，或者timer到期，都返回。会阻塞当前进程，但是确实Async&lt;/p&gt;</summary><category term="System"></category></entry><entry><title>Event Loop</title><link href="/event%20loop.html" rel="alternate"></link><updated>2014-07-26T00:00:00+02:00</updated><author><name>Qian Zhu</name></author><id>tag:,2014-07-26:event loop.html</id><summary type="html">&lt;h1&gt;Event loop and message queue&lt;/h1&gt;
&lt;p&gt;Event-loop和Message Queue是js中实现callback的方法。比如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;link&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;document&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getElementById&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="nx"&gt;link&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;addEventListener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;click&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;changeColor&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;style&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;black&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="p"&gt;});&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nx"&gt;init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里执行init,然后init添加了一个callback函数。具体的执行流程如下图所示:
&lt;img alt="javascript event loop" src="images/Javascript/javascript_event_loop.png" /&gt;&lt;/p&gt;
&lt;p&gt;Event loop首先执行init,然后init调用addEventListener,通知browser注册一个function handler。当用户点击link时，browser把一个message(包含事件，以及callback函数)放入js的Message Queue中。&lt;/p&gt;
&lt;p&gt;当Event Loop执行完在stack中的function后，会去message queue取地一个message，然后继续这个循环。这里显然是有异步操作的，但是这和js是单线程的并不矛盾。因为当用户点击link，然后生成一个message并且放入message queue是browser完成的。和js的执行环境没有关系。js不过是browser和用户交互的一个脚本语言。browser中还有很多其他的部分。&lt;/p&gt;
&lt;p&gt;优点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在js中不需要并发的操作。使js简单。&lt;/li&gt;
&lt;li&gt;在I/O bound的环境下表现的很好。但是在CPU-bound下表现不好。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;HTML5: Unblock w/Web Workers&lt;/h1&gt;
&lt;p&gt;在HTML5中，添加了一个新的特性:&lt;strong&gt;workers&lt;/strong&gt;. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Additional thread of execution for offloading expensive operations&lt;/li&gt;
&lt;li&gt;Separate event loop, message queue,stack&lt;/li&gt;
&lt;li&gt;Communicate with main thread through messaging&lt;/li&gt;
&lt;li&gt;Supported by all modern browsers + IE10&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="workers in javascript" src="images/Javascript/works_in_html5.png" /&gt;&lt;/p&gt;
&lt;p&gt;可以看到js中能够建立一个有独立event loop,message queue,和stack的worker去执行一些function. 当执行完毕后通过message和main thread通信。&lt;/p&gt;</summary><category term="System"></category></entry></feed>